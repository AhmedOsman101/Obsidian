## Security of Data Model: Cryptographic Algorithms

This section delves into different types of cryptographic algorithms used for protecting data .

- **Single-Key Algorithms (Symmetric Encryption)**
  - These algorithms rely on a **secret key**.
  - The key can be known to a single user (e.g., protecting stored data accessed only by the creator) or shared by two or more parties to protect communication.
  - They protect data from anyone outside the group who shares the secret key.
  - Symmetric encryption algorithms take the data to be protected and the secret key as input, producing an unintelligible transformation.
  - A corresponding decryption algorithm uses the transformed data and the _same_ secret key to recover the original data.
- **Message Authentication Code (MAC)**
  - A MAC is a data element associated with a data block or message.
  - It is generated by a cryptographic transformation using a secret key and typically a cryptographic hash function of the message.
  - The MAC allows someone in possession of the secret key to **verify the integrity** of the message.
  - If the recipient calculates the MAC on the received message and it matches the accompanying MAC, this provides assurance that the message has not been altered.
- **Forms of Symmetric Encryption**
  - **Block cipher:** Operates on data in fixed-size blocks, often 128 bits. In common modes of operation, the transformation depends not only on the current data block and key but also on preceding blocks. Block ciphers take 'b' bits of input and produce 'b' bits of output. Larger plaintext is broken into 'b'-bit blocks.
  - **Stream cipher:** Operates on data as a sequence of bits. It typically uses an exclusive-OR (XOR) operation for a bit-by-bit transformation. The transformation depends on a secret key.
- **Modes of Operation for Block Ciphers**
  - The source lists five modes for DES and AES: Electronic Code Book (ECB), Cipher Block Chaining (CBC), Cipher Feed Back (CFB), Output Feed Back (OFB), and Counter (CTR).
  - Examples are provided for **ECB**, showing steps involving ASCII conversion, binary representation, and XORing plaintext blocks with the key.
  - An example is provided for **CBC**, which depends on XORing the previous cipher block with the current plaintext block. It uses an **Initialization Vector (IV)** for the first block. The example shows steps involving an IV and XOR operations.
  - The **OFB** mode uses an IV shift register. The IV must be delivered securely. The process starts with the IV, processes it, XORs with the key, processes the result, then XORs with the plaintext, and the result is processed and used as the initial vector for the next step.
- **Algorithms to Create Keys**
  - A **Key** is a secret, like a password, used for encryption and decryption .
  - **Key Management** is crucial and involves the generation, distribution, storage, and protection of cryptographic keys . Keys must be kept secure and accessible only to authorized users . Key management includes key exchange protocols .
  - Key generation can involve creating a key from an original message and a random number, or generating a random key using a **secure random number generator** .
  - **Random Number Generation** is important for encryption. A sequence of numbers is considered random if it meets two criteria: **Uniform distribution** (frequency of each number is approximately the same) and **Independence** (no value can be inferred from others). The requirements are randomness and unpredictability.
  - **Pseudorandom Number Generators (PRNGs)** are deterministic algorithms that produce sequences that are _not_ statistically random.
  - The **Linear Congruential Generator (LCG)** is a recursive PRNG algorithm where each new number depends on the previous one. It requires a starting **seed** value. The algorithm is defined by four parameters: seed, constant multiplier, increment, and modulus (m). The choice of parameters determines the sequence properties, and properly chosen parameters can make the pseudorandom numbers appear random. An example of computing values using an LCG with specific parameters and the modulo operator is provided. For generating long sequences, the modulus 'm' is typically chosen to be very large, often near 2^31.
  - Proposed tests to evaluate a random number generator include: T1: Full-period generation (generates all numbers from 0 to m before repeating), T2: The sequence should _appear_ random (assessed with statistical tests), and T3: Efficient implementation with 32-bit arithmetic.
  - The **Blum Blum Shub Generator (BBS)** is mentioned as having a strong public proof of cryptographic strength. Its procedure involves choosing two large prime numbers p and q such that p ≡ q ≡ 3 (mod 4), computing n = p \* q, and choosing a random number s relatively prime to n, then following a defined algorithm to produce bits.
- **Two-Key Algorithms (Asymmetric Encryption)**
  - Also known as asymmetric cryptography .
  - A secret key is divided into two parts: a **public key** and a **private key**.
  - The public key can be shared openly, while the private key must be kept secret.
  - The **RSA (Rivest–Shamir–Adleman)** algorithm is an asymmetric algorithm using a public and private key pair.
  - Steps to compute the **public key (n, e)** involve choosing two prime numbers p and q, computing n = p _ q and Euler's phi (Φ) = (p-1) _ (q-1), and choosing 'e' such that 1 < e < Φ(n) and e is coprime with Φ(n).
  - Steps to compute the **private key (n, d)** involve calculating 'd' as the modular multiplicative inverse of 'e' modulo Φ(n), such that (d \* e) ≡ 1 mod Φ(n). The calculated 'd' is the private key.
  - An example of the RSA algorithm is presented , showing a public key (n,e) = (33,7) .
  - Notably, in "assignment2", the private key calculation algorithm is altered to use LCG .

## Operating System Security

This section discusses security principles and components within operating systems .

- **Layers of a Computer System:** Security can be compromised by attacks from lower layers . A key question is where security should be placed .
- **OS Protection Principles:** The foundation of OS protection is **separation** . Four types are described:
  - **Physical separation:** Using different physical objects for processes with different security needs (e.g., separate printers) .
  - **Temporal separation:** Executing processes with different security requirements at different times .
  - **Logical separation:** Giving users the illusion that no other processes exist by constraining program access to permitted domains .
  - **Cryptographic separation:** Hiding data to make it unintelligible to unauthorized users .
- **Protected Objects:** Ideally, all objects in the OS need protection, particularly those that are shareable . Examples include memory, I/O devices, programs, procedures, data, hardware components (bus control, interrupt control, status registers), and normal OS mechanisms like file and memory management .
- **Trusted Operating System Concepts:**
  - The **kernel** is the part of the OS performing the lowest-level functions .
  - The **security kernel** is responsible for enforcing the OS's security mechanisms .
  - The **reference monitor (RM)** is a part of the security kernel that controls access to objects .
  - The **trusted computing base (TCB)** encompasses everything in the trusted OS required to enforce the security policy .
- **Security Policy and Security Model:**
  - A **security policy** is a statement outlining the security expected from the system, expressed as well-defined, consistent, and implementable rules .
  - A **security model** is a representation of the security policy for the OS .
  - A **formal security model** is a mathematical description of the policy rules, used for formal proofs of security .
- **Development of a Secure OS:** This involves a six-step process: analyzing the system, choosing/defining a security policy, choosing/creating a security model, choosing an implementation method, making a conceptual design, verifying the design, making an implementation, and verifying the implementation . Note that feedback loops and potential errors exist throughout these steps .
- **Security Maintenance:** Maintaining security is a continuous process . Key activities include monitoring logs, performing regular backups, recovering from compromises, regular security testing, and using appropriate software maintenance processes for patching, updating critical software, and revising configuration .
- **Linux/Unix Security:**
  - **Patch management:** Keeping security patches up to date is a critical control . Configuration is often in text files (/etc or installation trees), with user configurations in hidden "dot" files . A crucial security improvement is disabling unnecessary services and applications .
  - **Users, groups, and permissions:** Access is controlled by granting read, write, and execute permissions to the owner, group, and others for resources .
  - A **local exploit** is a software vulnerability used by an attacker to gain elevated privileges .
  - A **remote exploit** is a software vulnerability in a network server that can be triggered remotely .
- **Windows Security:**
  - **Patch management:** Tools like "Windows update" and "windows server update service" assist with maintenance .
  - **User administration and access controls:** Systems implement **discretionary access controls** . Vista and later versions include **mandatory integrity controls** . Objects are labeled with integrity levels (low, medium, high, system), and the system ensures a subject's integrity level is equal to or higher than the object's level . This implements a form of the **Biba integrity model** .
  - **Application and service configuration:** Much configuration is centralized in the **registry**, a database of keys and values . The registry editor can directly modify keys, useful for bulk changes .
